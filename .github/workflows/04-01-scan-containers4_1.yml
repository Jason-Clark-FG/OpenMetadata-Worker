name: "Worker: Step 4.1.4.1 - Scan Containers"

on:
  workflow_run:
    workflows: ["Worker: Step 3 - Modify Work Repo Matrix"]
    types:
      - completed
  workflow_dispatch:
    inputs:
      use_spot_vms:
        description: 'Use spot VMs (uncheck for regular VMs)'
        required: false
        type: boolean
        default: true
      vm_size:
        description: 'VM Size'
        required: false
        type: choice
        default: 'Standard_D4as_v5'
        options:
          - 'Standard_D4as_v5'
          - 'Standard_F8s_v2'
          - 'Standard_D8as_v5'

env:
  IMAGE_REGISTRY_1: docker.getcollate.io
  IMAGE_REGISTRY_2: docker.elastic.co
  IMAGE_OWNER_1: openmetadata
  IMAGE_OWNER_2: elasticsearch
  IMAGE_NAME_1: db
  IMAGE_NAME_2: ingestion
  IMAGE_NAME_3: server
  IMAGE_NAME_4: elasticsearch
  IMAGE_TAG_1: "1.1.6"
  IMAGE_TAG_2: "7.16.3"
  SCAN_RETRIES: 4
  REPORTS_OUT: false

jobs:
  # Determine which images need to be scanned
  setup-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.matrix.outputs.matrix }}
      use_spot: ${{ steps.config.outputs.use_spot }}
      vm_size: ${{ steps.config.outputs.vm_size }}
    steps:
    - name: Determine VM Configuration
      id: config
      run: |
        # Determine VM configuration based on trigger type
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          # Manual trigger - use user inputs or safer defaults
          use_spot="${{ github.event.inputs.use_spot_vms }}"
          vm_size="${{ github.event.inputs.vm_size }}"

          # Default to smaller, more stable VM if not specified
          if [[ -z "$vm_size" ]]; then
            vm_size="Standard_D4as_v5"
          fi

          # Default to false for spot if not specified (safer for manual runs)
          if [[ -z "$use_spot" || "$use_spot" == "false" ]]; then
            use_spot="false"
            echo "Manual dispatch: Using regular VMs with size $vm_size"
          else
            use_spot="true"
            echo "Manual dispatch: Using spot VMs with size $vm_size"
          fi
        else
          # Automated trigger (workflow_run) - use larger spot VMs for better performance
          use_spot="true"
          vm_size="Standard_F8s_v2"
          echo "Automated workflow_run trigger: Using larger spot VMs with size $vm_size for better performance"
        fi

        echo "use_spot=$use_spot" >> $GITHUB_OUTPUT
        echo "vm_size=$vm_size" >> $GITHUB_OUTPUT

    - name: Generate Matrix
      id: matrix
      run: |
        matrix_items=()

        # Generate random suffix for labels
        prod_suffix=$(shuf -er -n8 {a..z} | paste -sd '')
        dev_suffix=$(shuf -er -n8 {a..z} | paste -sd '')
        latest_suffix=$(shuf -er -n8 {a..z} | paste -sd '')

        # Build JSON array using jq for proper escaping
        matrix_json=$(jq -n '[]')

        # Always scan PROD
        matrix_json=$(echo "$matrix_json" | jq --arg tag "${{ vars.PROD_RELEASE_BRANCH }}" \
          --arg suffix "prod" \
          --arg name "Production" \
          --arg label "spot-prod-${prod_suffix}" \
          '. += [{"tag": $tag, "suffix": $suffix, "name": $name, "label": $label}]')

        # Scan DEV if different from PROD
        if [[ "${{ vars.DEV_RELEASE_BRANCH }}" != "${{ vars.PROD_RELEASE_BRANCH }}" ]]; then
          matrix_json=$(echo "$matrix_json" | jq --arg tag "${{ vars.DEV_RELEASE_BRANCH }}" \
            --arg suffix "dev" \
            --arg name "Development" \
            --arg label "spot-dev-${dev_suffix}" \
            '. += [{"tag": $tag, "suffix": $suffix, "name": $name, "label": $label}]')
        fi

        # Scan LATEST if different from both DEV and PROD
        if [[ "${{ vars.OM_LATEST_RELEASE }}" != "${{ vars.DEV_RELEASE_BRANCH }}" && "${{ vars.OM_LATEST_RELEASE }}" != "${{ vars.PROD_RELEASE_BRANCH }}" ]]; then
          matrix_json=$(echo "$matrix_json" | jq --arg tag "${{ vars.OM_LATEST_RELEASE }}" \
            --arg suffix "latest" \
            --arg name "Latest" \
            --arg label "spot-latest-${latest_suffix}" \
            '. += [{"tag": $tag, "suffix": $suffix, "name": $name, "label": $label}]')
        fi
        echo "Generated matrix: $matrix_json"

        # Enhanced JSON validation with detailed debugging
        if echo "$matrix_json" | jq empty 2>/dev/null; then
          echo "âœ… JSON validation successful"
          echo "Matrix structure:"
          echo "$matrix_json" | jq .
          echo "Matrix items count: $(echo "$matrix_json" | jq length)"
          # Output compact JSON for GitHub Actions (single line, no formatting)
          compact_matrix=$(echo "$matrix_json" | jq -c .)
          echo "matrix=$compact_matrix" >> $GITHUB_OUTPUT
        else
          echo "âŒ JSON validation failed"
          echo "Invalid JSON: $matrix_json"
          echo "JSON error details:"
          echo "$matrix_json" | jq . 2>&1 || true
          echo "Environment variables:"
          echo "PROD_RELEASE_BRANCH: ${{ vars.PROD_RELEASE_BRANCH }}"
          echo "DEV_RELEASE_BRANCH: ${{ vars.DEV_RELEASE_BRANCH }}"
          echo "OM_LATEST_RELEASE: ${{ vars.OM_LATEST_RELEASE }}"
          exit 1
        fi

  # Debug matrix generation
  debug-matrix:
    needs: setup-matrix
    runs-on: ubuntu-latest
    steps:
    - name: Debug Matrix Output
      run: |
        echo "Matrix output from setup-matrix job:"
        echo '${{ needs.setup-matrix.outputs.matrix }}'
        echo "VM Configuration:"
        echo "Use Spot: ${{ needs.setup-matrix.outputs.use_spot }}"
        echo "VM Size: ${{ needs.setup-matrix.outputs.vm_size }}"
        echo "Parsing with jq:"
        echo '${{ needs.setup-matrix.outputs.matrix }}' | jq .
        echo "Matrix items count:"
        echo '${{ needs.setup-matrix.outputs.matrix }}' | jq length

  # Create VMs for each image scan (spot or regular based on configuration)
  create-vms:
    needs: [setup-matrix, debug-matrix]
    strategy:
      matrix:
        image: ${{ fromJson(needs.setup-matrix.outputs.matrix) }}
      fail-fast: false
      max-parallel: 0  # Explicitly allow unlimited parallel jobs
    uses: Jason-Clark-FG/azure-github-runner/.github/workflows/create.yml@main
    with:
      RESOURCE_GROUP_NAME: "rg-t-wus2-ghrunner-01"
      LOCATION: "westus2"
      VM_IMAGE: ${{ vars.VM_IMAGE_REF }}
      VM_SPOT: ${{ needs.setup-matrix.outputs.use_spot }}
      VM_SIZE: ${{ needs.setup-matrix.outputs.vm_size }}
      VM_DISK_SIZE: "127"
      VM_NAME: "az-ghrunner-01t-${{ needs.setup-matrix.outputs.use_spot == 'true' && 'spot' || 'regular' }}-${{ matrix.image.suffix }}"
      VM_USERNAME: "ghradmin"
      STORAGE_BLOB_URI: "https://sfgdwus2syspro8.blob.core.windows.net/"
      SSH_KEY_BASENAME: id_rsa-${{ matrix.image.suffix }}
      RUNNER_LABEL: ${{ matrix.image.label }}
    secrets:
      ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
      ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
      GH_TOKEN: ${{ secrets.GH_TOKEN }}

  # Build and scan images
  build-and-scan:
    needs: [setup-matrix, debug-matrix, create-vms]
    # Only run if not cancelled and ALL VM creation jobs succeeded
    if: ${{ !cancelled() && !contains(needs.create-vms.result, 'failure') && !contains(needs.create-vms.result, 'cancelled') }}
    strategy:
      matrix:
        image: ${{ fromJson(needs.setup-matrix.outputs.matrix) }}
      fail-fast: false
      max-parallel: 0  # Explicitly allow unlimited parallel jobs
    # Use a dynamic runner label based on the matrix suffix
    runs-on: ${{ matrix.image.label }}
    timeout-minutes: 120
    outputs:
      success-prod: ${{ matrix.image.suffix == 'prod' && steps.mark-success.outputs.success || '' }}
      success-dev: ${{ matrix.image.suffix == 'dev' && steps.mark-success.outputs.success || '' }}
      success-latest: ${{ matrix.image.suffix == 'latest' && steps.mark-success.outputs.success || '' }}
    permissions:
      security-events: write
      actions: read
      contents: read
      packages: write

    steps:
    - name: Check VM Creation Success
      run: |
        echo "Checking VM creation status..."
        echo "VM creation result: ${{ needs.create-vms.result }}"
        if [[ "${{ needs.create-vms.result }}" != "success" ]]; then
          echo "âŒ VM creation failed or was cancelled. Cannot proceed with scanning."
          echo "This could be due to:"
          echo "  - Azure quota limits (vCPU, resource limits)"
          echo "  - Network connectivity issues"
          echo "  - Authentication problems"
          echo "  - Resource group issues"
          exit 1
        fi
        echo "âœ… VM creation successful, proceeding with scan"

    - name: Wait for Runner Registration
      timeout-minutes: 5  # Short timeout just for runner check
      run: |
        echo "ðŸ” Verifying runner availability for ${{ matrix.image.name }} scan"
        echo "Runner: $(hostname)"
        echo "Matrix suffix: ${{ matrix.image.suffix }}"
        echo "Runner label: ${{ matrix.image.label }}"
        echo "VM Type: ${{ needs.setup-matrix.outputs.use_spot == 'true' && 'Spot' || 'Regular' }}"
        echo "VM Size: ${{ needs.setup-matrix.outputs.vm_size }}"
        echo "System ready at $(date)"

    - name: Debug Parallel Execution
      run: |
        echo "ðŸš€ Starting parallel scan for ${{ matrix.image.name }} at $(date)"
        echo "Runner: $(hostname)"
        echo "Matrix suffix: ${{ matrix.image.suffix }}"

    - name: Checkout Self
      uses: actions/checkout@v4

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USER }}
        password: ${{ secrets.DOCKER_PAT }}

    - name: Show Info
      run: |
        vm_type="${{ needs.setup-matrix.outputs.use_spot == 'true' && 'SPOT' || 'REGULAR' }}"
        echo "ðŸŸ¡ Running ${{ matrix.image.name }} scan on $vm_type instance"
        echo "Image: ${{ env.IMAGE_REGISTRY_1 }}/${{ env.IMAGE_OWNER_1 }}/${{ env.IMAGE_NAME_2 }}:${{ matrix.image.tag }}"
        ls -lDR ${GITHUB_WORKSPACE} | grep ':$'
        df -h
        env | sort

    - name: Setup Docker buildx
      uses: docker/setup-buildx-action@v3

    - name: "Mend: Scan Image - ${{ matrix.image.name }}"
      id: mend-cli-scan
      if: ${{ github.event_name != 'pull_request_target' }}
      shell: bash
      run: |
        # Install Mend
        curl -fsSL https://downloads.mend.io/cli/linux_amd64/mend -o /usr/local/bin/mend && chmod +x /usr/local/bin/mend
        mend version

        # Create reports directory
        mkdir -p ./reports
        ls -laR ~/.mend || true
        df -h

        check_eviction_notice() {
          # Only check for eviction if using spot VMs
          if [[ "${{ needs.setup-matrix.outputs.use_spot }}" != "true" ]]; then
            return 1  # Not a spot VM, no eviction possible
          fi

          response=$(curl -s -m 5 -H "Metadata:true" "http://169.254.169.254/metadata/scheduledevents?api-version=2019-08-01" 2>/dev/null || echo '{}')
          if echo "$response" | jq -e '.Events[]? | select(.EventType == "Preempt")' > /dev/null 2>&1; then
            echo "âš ï¸ Spot eviction notice received!"
            return 0
          fi
          return 1
        }

        # Function to run mend with eviction monitoring
        run_mend_with_monitoring() {
          local image_ref="$1"
          local output_file="$2"

          echo "ðŸ” Starting ${{ matrix.image.name }} scan: $image_ref"

          # Start the scan in background
          mend image "$image_ref" --filename "$output_file" --format sarif --scope "*//DataCatalogue//*" &
          local mend_pid=$!

          # Monitor for eviction notices while scan runs (only for spot VMs)
          if [[ "${{ needs.setup-matrix.outputs.use_spot }}" == "true" ]]; then
            while kill -0 $mend_pid 2>/dev/null; do
              if check_eviction_notice; then
                echo "ðŸ›‘ Spot eviction detected during ${{ matrix.image.name }} scan, terminating gracefully..."
                kill $mend_pid 2>/dev/null || true
                wait $mend_pid 2>/dev/null || true
                exit 1
              fi
              sleep 30
            done
          fi

          # Wait for scan to complete and get result
          wait $mend_pid
          return $?
        }

        # Run the scan with retries
        for ((tries=1;tries <= ${{ env.SCAN_RETRIES }};tries++)); do
          echo "ðŸ”„ ${{ matrix.image.name }} scan attempt $tries of ${{ env.SCAN_RETRIES }}"

          if run_mend_with_monitoring "${{ env.IMAGE_REGISTRY_1 }}/${{ env.IMAGE_OWNER_1 }}/${{ env.IMAGE_NAME_2 }}:${{ matrix.image.tag }}" "./reports/${{ env.IMAGE_NAME_2 }}-${{ matrix.image.tag }}.sarif"; then
            echo "âœ… ${{ matrix.image.name }} scan completed successfully!"
            break
          else
            echo "âŒ ${{ matrix.image.name }} scan failed (attempt $tries)"
            if [[ $tries -eq ${{ env.SCAN_RETRIES }} ]]; then
              echo "ðŸš¨ All retries exhausted for ${{ matrix.image.name }} scan"
              exit 1
            fi
            sleep 30
          fi

          ls -laR ~/.mend/logs || true
          df -h
        done

        echo "ðŸŽ‰ ${{ matrix.image.name }} scan completed successfully"
        ls -laR ~/.mend/logs || true
        df -h
      env:
        MEND_URL: ${{ vars.MEND_URL }}
        MEND_EMAIL: ${{ secrets.MEND_EMAIL }}
        MEND_USER_KEY: ${{ secrets.MEND_USER_KEY }}
        MEND_LOG_LEVEL: DEBUG

    - name: SARIF Multitool
      id: sarif-multitool
      uses: microsoft/sarif-actions@v0.1
      with:
        command: merge ./reports/*.sarif --recurse true --output-directory=./reports/ --output-file=MendResults-${{ matrix.image.suffix }}.sarif

    - name: "Mend: Upload SARIF results - ${{ matrix.image.name }}"
      id: upload-sarif
      if: ${{ github.event_name != 'pull_request_target' && env.REPORTS_OUT == 'true' }}
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: './reports/MendResults-${{ matrix.image.suffix }}.sarif'
        wait-for-processing: false

    - name: "Mend: Upload logs - ${{ matrix.image.name }}"
      uses: actions/upload-artifact@v4
      with:
        name: mend_io_cn_scan_logs_${{ needs.setup-matrix.outputs.use_spot == 'true' && 'spot' || 'regular' }}_${{ matrix.image.suffix }}
        path: ~/.mend/logs/cn/*.log

    - name: Mark Success
      id: mark-success
      run: echo "success=true" >> $GITHUB_OUTPUT

  # Sequential cleanup VMs (wait for build jobs to complete first)
  cleanup-vms:
    needs: [setup-matrix, create-vms, build-and-scan]
    # Always run cleanup if VMs were created, regardless of build success/failure
    # This ensures cleanup happens even if builds fail or are cancelled
    if: ${{ always() && !contains(needs.create-vms.result, 'failure') && !contains(needs.create-vms.result, 'cancelled') && !contains(needs.create-vms.result, 'skipped') }}
    strategy:
      matrix:
        image: ${{ fromJson(needs.setup-matrix.outputs.matrix) }}
      fail-fast: false
      # Sequential cleanup to avoid race conditions and deletion conflicts
      max-parallel: 1
    uses: Jason-Clark-FG/azure-github-runner/.github/workflows/delete.yml@main
    with:
      RESOURCE_GROUP_NAME: "rg-t-wus2-ghrunner-01"
      VM_NAME: "az-ghrunner-01t-${{ needs.setup-matrix.outputs.use_spot == 'true' && 'spot' || 'regular' }}-${{ matrix.image.suffix }}"
      VM_USERNAME: "ghradmin"
      SSH_KEY_BASENAME: id_rsa-${{ matrix.image.suffix }}
    secrets:
      ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
      ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
      GH_TOKEN: ${{ secrets.GH_TOKEN }}

  # Emergency cleanup job that runs if the main cleanup fails
  emergency-cleanup:
    needs: [setup-matrix, create-vms, cleanup-vms]
    # Run if cleanup failed and VMs were actually created
    if: ${{ always() && needs.cleanup-vms.result == 'failure' && !contains(needs.create-vms.result, 'failure') }}
    runs-on: ubuntu-latest
    steps:
    - name: Emergency VM Cleanup
      run: |
        echo "ðŸš¨ Main cleanup failed, attempting emergency cleanup"
        echo "This is a fallback to ensure VMs don't get orphaned"

        # Install Azure CLI
        curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash

        # Login to Azure
        az login --service-principal \
          --username "${{ secrets.ARM_CLIENT_ID }}" \
          --password "${{ secrets.ARM_CLIENT_SECRET }}" \
          --tenant "${{ secrets.ARM_TENANT_ID }}"

        az account set --subscription "${{ secrets.ARM_SUBSCRIPTION_ID }}"

        # List and delete VMs that match our naming pattern
        matrix='${{ needs.setup-matrix.outputs.matrix }}'
        vm_type="${{ needs.setup-matrix.outputs.use_spot == 'true' && 'spot' || 'regular' }}"

        echo "$matrix" | jq -r '.[] | .suffix' | while read suffix; do
          vm_name="az-ghrunner-01t-${vm_type}-${suffix}"
          echo "Checking for VM: $vm_name"

          if az vm show --resource-group "rg-t-wus2-ghrunner-01" --name "$vm_name" --output none 2>/dev/null; then
            echo "ðŸ—‘ï¸ Found orphaned VM $vm_name, attempting deletion..."

            # Force delete VM and all associated resources
            az vm delete --resource-group "rg-t-wus2-ghrunner-01" --name "$vm_name" --yes --force-deletion || true

            # Also try to clean up associated resources
            az network nsg delete --resource-group "rg-t-wus2-ghrunner-01" --name "${vm_name}-nsg" || true
            az network public-ip delete --resource-group "rg-t-wus2-ghrunner-01" --name "${vm_name}-ip" || true
            az network nic delete --resource-group "rg-t-wus2-ghrunner-01" --name "${vm_name}-nic" || true
            az disk delete --resource-group "rg-t-wus2-ghrunner-01" --name "${vm_name}-disk" --yes || true

            echo "âœ… Emergency cleanup completed for $vm_name"
          else
            echo "âœ… VM $vm_name not found (already cleaned up)"
          fi
        done

  # Optional: Determine which scans failed and need retry (only if using spot VMs and they failed)
  check-spot-failures:
    needs: [setup-matrix, build-and-scan]
    runs-on: ubuntu-latest
    # Only check for failures if we were using spot VMs and some jobs failed
    if: ${{ always() && needs.setup-matrix.outputs.use_spot == 'true' && contains(needs.build-and-scan.result, 'failure') }}
    outputs:
      failed-matrix: ${{ steps.failed.outputs.matrix }}
      has-failures: ${{ steps.failed.outputs.has-failures }}
    steps:
    - name: Determine Failed Spot Scans
      id: failed
      run: |
        echo "Checking for failed spot VM scans that need retry on regular VMs..."

        original_matrix='${{ needs.setup-matrix.outputs.matrix }}'
        echo "Original matrix: $original_matrix"

        # For now, create a simplified failed matrix
        # In a real scenario, you'd need more sophisticated logic to determine which specific matrix jobs failed
        failed_matrix=$(echo "$original_matrix")

        # Check if we have any failures
        if [[ "$(echo "$failed_matrix" | jq length)" -gt 0 ]]; then
          echo "has-failures=true" >> $GITHUB_OUTPUT
          compact_failed_matrix=$(echo "$failed_matrix" | jq -c .)
          echo "matrix=$compact_failed_matrix" >> $GITHUB_OUTPUT
          echo "Found failed scans that need retry: $compact_failed_matrix"
        else
          echo "has-failures=false" >> $GITHUB_OUTPUT
          echo "matrix=[]" >> $GITHUB_OUTPUT
          echo "No failed scans found"
        fi

  # Create regular VMs for failed spot scans (only if spot failed and we're not cancelled)
  create-retry-vms:
    needs: [check-spot-failures, cleanup-vms, emergency-cleanup]
    if: ${{ !cancelled() && needs.check-spot-failures.outputs.has-failures == 'true' && (needs.cleanup-vms.result == 'success' || needs.emergency-cleanup.result == 'success') }}
    strategy:
      matrix:
        image: ${{ fromJson(needs.check-spot-failures.outputs.failed-matrix) }}
      fail-fast: false
    uses: Jason-Clark-FG/azure-github-runner/.github/workflows/create.yml@main
    with:
      RESOURCE_GROUP_NAME: "rg-t-wus2-ghrunner-01"
      LOCATION: "westus2"
      VM_IMAGE: ${{ vars.VM_IMAGE_REF }}
      VM_SPOT: "False"  # Always use regular instances for retries
      VM_SIZE: "Standard_D4as_v5"  # Use smaller, more stable size for retries
      VM_DISK_SIZE: "127"
      VM_NAME: "az-ghrunner-01t-retry-${{ matrix.image.suffix }}"
      VM_USERNAME: "ghradmin"
      STORAGE_BLOB_URI: "https://sfgdwus2syspro8.blob.core.windows.net/"
      SSH_KEY_BASENAME: id_rsa-retry-${{ matrix.image.suffix }}
      RUNNER_LABEL: retry-${{ matrix.image.label }}
    secrets:
      ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
      ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
      GH_TOKEN: ${{ secrets.GH_TOKEN }}

  # Retry failed scans on regular VMs
  retry-on-regular:
    needs: [check-spot-failures, create-retry-vms]
    if: ${{ !cancelled() && needs.create-retry-vms.result == 'success' }}
    strategy:
      matrix:
        image: ${{ fromJson(needs.check-spot-failures.outputs.failed-matrix) }}
      fail-fast: false
    runs-on: retry-${{ matrix.image.label }}
    timeout-minutes: 120
    permissions:
      security-events: write
      actions: read
      contents: read
      packages: write

    steps:
    - name: Checkout Self
      uses: actions/checkout@v4

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USER }}
        password: ${{ secrets.DOCKER_PAT }}

    - name: Show Info
      run: |
        echo "ðŸŸ¢ Running ${{ matrix.image.name }} scan on REGULAR instance (spot retry)"
        echo "Image: ${{ env.IMAGE_REGISTRY_1 }}/${{ env.IMAGE_OWNER_1 }}/${{ env.IMAGE_NAME_2 }}:${{ matrix.image.tag }}"
        df -h

    - name: Setup Docker buildx
      uses: docker/setup-buildx-action@v3

    - name: "Mend: Scan Image - ${{ matrix.image.name }} (Retry)"
      id: mend-cli-scan
      if: ${{ github.event_name != 'pull_request_target' }}
      shell: bash
      run: |
        # Install Mend
        curl -fsSL https://downloads.mend.io/cli/linux_amd64/mend -o /usr/local/bin/mend && chmod +x /usr/local/bin/mend
        mend version

        # Create reports directory
        mkdir -p ./reports

        # Run the scan with retries (simpler version for regular VM)
        for ((tries=1;tries <= ${{ env.SCAN_RETRIES }};tries++)); do
          echo "ðŸ”„ ${{ matrix.image.name }} RETRY scan attempt $tries of ${{ env.SCAN_RETRIES }}"

          if mend image "${{ env.IMAGE_REGISTRY_1 }}/${{ env.IMAGE_OWNER_1 }}/${{ env.IMAGE_NAME_2 }}:${{ matrix.image.tag }}" --filename "./reports/${{ env.IMAGE_NAME_2 }}-${{ matrix.image.tag }}.sarif" --format sarif --scope "*//DataCatalogue//*"; then
            echo "âœ… ${{ matrix.image.name }} RETRY scan completed successfully!"
            break
          else
            echo "âŒ ${{ matrix.image.name }} RETRY scan failed (attempt $tries)"
            if [[ $tries -eq ${{ env.SCAN_RETRIES }} ]]; then
              echo "ðŸš¨ All RETRY attempts exhausted for ${{ matrix.image.name }} scan"
              exit 1
            fi
            sleep 30
          fi
        done
      env:
        MEND_URL: ${{ vars.MEND_URL }}
        MEND_EMAIL: ${{ secrets.MEND_EMAIL }}
        MEND_USER_KEY: ${{ secrets.MEND_USER_KEY }}
        MEND_LOG_LEVEL: DEBUG

    - name: SARIF Multitool
      uses: microsoft/sarif-actions@v0.1
      with:
        command: merge ./reports/*.sarif --recurse true --output-directory=./reports/ --output-file=MendResults-retry-${{ matrix.image.suffix }}.sarif

    - name: "Mend: Upload SARIF results - ${{ matrix.image.name }} (Retry)"
      if: ${{ github.event_name != 'pull_request_target' && env.REPORTS_OUT == 'true' }}
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: './reports/MendResults-retry-${{ matrix.image.suffix }}.sarif'
        wait-for-processing: false

    - name: "Mend: Upload logs - ${{ matrix.image.name }} (Retry)"
      uses: actions/upload-artifact@v4
      with:
        name: mend_io_cn_scan_logs_retry_${{ matrix.image.suffix }}
        path: ~/.mend/logs/cn/*.log

  # Final cleanup of retry VMs
  cleanup-retry-vms:
    needs: [check-spot-failures, create-retry-vms, retry-on-regular]
    if: ${{ always() && !contains(needs.create-retry-vms.result, 'failure') && !contains(needs.create-retry-vms.result, 'cancelled') && !contains(needs.create-retry-vms.result, 'skipped') }}
    strategy:
      matrix:
        image: ${{ fromJson(needs.check-spot-failures.outputs.failed-matrix) }}
      fail-fast: false
      max-parallel: 1  # Sequential cleanup
    uses: Jason-Clark-FG/azure-github-runner/.github/workflows/delete.yml@main
    with:
      RESOURCE_GROUP_NAME: "rg-t-wus2-ghrunner-01"
      VM_NAME: "az-ghrunner-01t-retry-${{ matrix.image.suffix }}"
      VM_USERNAME: "ghradmin"
      SSH_KEY_BASENAME: id_rsa-retry-${{ matrix.image.suffix }}
    secrets:
      ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
      ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
      GH_TOKEN: ${{ secrets.GH_TOKEN }}

  # Final status report
  workflow-summary:
    needs: [setup-matrix, create-vms, build-and-scan, cleanup-vms, emergency-cleanup, check-spot-failures, create-retry-vms, retry-on-regular, cleanup-retry-vms]
    if: ${{ always() }}
    runs-on: ubuntu-latest
    steps:
    - name: Workflow Summary
      run: |
        echo "ðŸ” Container Scan Workflow Summary"
        echo "=================================="
        echo "VM Configuration:"
        echo "  - Use Spot: ${{ needs.setup-matrix.outputs.use_spot }}"
        echo "  - VM Size: ${{ needs.setup-matrix.outputs.vm_size }}"
        echo "  - Trigger: ${{ github.event_name }}"
        echo ""
        echo "Job Results:"
        echo "  - setup-matrix: ${{ needs.setup-matrix.result }}"
        echo "  - create-vms: ${{ needs.create-vms.result }}"
        echo "  - build-and-scan: ${{ needs.build-and-scan.result }}"
        echo "  - cleanup-vms: ${{ needs.cleanup-vms.result }}"
        echo "  - emergency-cleanup: ${{ needs.emergency-cleanup.result }}"
        echo "  - check-spot-failures: ${{ needs.check-spot-failures.result }}"
        echo "  - create-retry-vms: ${{ needs.create-retry-vms.result }}"
        echo "  - retry-on-regular: ${{ needs.retry-on-regular.result }}"
        echo "  - cleanup-retry-vms: ${{ needs.cleanup-retry-vms.result }}"
        echo ""

        # Check for potential issues
        if [[ "${{ needs.create-vms.result }}" == "failure" ]]; then
          echo "âš ï¸  VM Creation Failed - Possible Issues:"
          echo "  - Azure quota exceeded (check vCPU limits)"
          echo "  - Network connectivity problems"
          echo "  - Authentication issues"
          echo "  - Resource group access problems"
        fi

        if [[ "${{ needs.cleanup-vms.result }}" == "failure" ]]; then
          echo "âš ï¸  VM Cleanup Failed:"
          echo "  - Check emergency cleanup results"
          echo "  - Manual cleanup may be required"
          echo "  - Verify GH_TOKEN permissions"
        fi

        if [[ "${{ needs.emergency-cleanup.result }}" == "success" ]]; then
          echo "âœ… Emergency cleanup was successful"
        elif [[ "${{ needs.emergency-cleanup.result }}" == "failure" ]]; then
          echo "ðŸš¨ Emergency cleanup also failed - manual intervention required"
        fi

        echo ""
        echo "Matrix scanned: ${{ needs.setup-matrix.outputs.matrix }}"
