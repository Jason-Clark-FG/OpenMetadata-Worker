name: "Worker: Step 4.1.4.1 - Scan Containers"

on:
  workflow_run:
    workflows: ["Worker: Step 3 - Modify Work Repo Matrix"]
    types:
      - completed
  workflow_dispatch:

env:
  IMAGE_REGISTRY_1: docker.getcollate.io
  IMAGE_REGISTRY_2: docker.elastic.co
  IMAGE_OWNER_1: openmetadata
  IMAGE_OWNER_2: elasticsearch
  IMAGE_NAME_1: db
  IMAGE_NAME_2: ingestion
  IMAGE_NAME_3: server
  IMAGE_NAME_4: elasticsearch
  IMAGE_TAG_1: "1.1.6"
  IMAGE_TAG_2: "7.16.3"
  SCAN_RETRIES: 4
  REPORTS_OUT: false

jobs:
  # Determine which images need to be scanned
  setup-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.matrix.outputs.matrix }}
    steps:
    - name: Generate Matrix
      id: matrix
      run: |
        matrix_items=()

        # Generate random suffix for labels
        prod_suffix=$(shuf -er -n8 {a..z} | paste -sd '')
        dev_suffix=$(shuf -er -n8 {a..z} | paste -sd '')
        latest_suffix=$(shuf -er -n8 {a..z} | paste -sd '')

        # Build JSON array using jq for proper escaping
        matrix_json=$(jq -n '[]')

        # Always scan PROD
        matrix_json=$(echo "$matrix_json" | jq --arg tag "${{ vars.PROD_RELEASE_BRANCH }}" \
          --arg suffix "prod" \
          --arg name "Production" \
          --arg label "spot-prod-${prod_suffix}" \
          '. += [{"tag": $tag, "suffix": $suffix, "name": $name, "label": $label}]')

        # Scan DEV if different from PROD
        if [[ "${{ vars.DEV_RELEASE_BRANCH }}" != "${{ vars.PROD_RELEASE_BRANCH }}" ]]; then
          matrix_json=$(echo "$matrix_json" | jq --arg tag "${{ vars.DEV_RELEASE_BRANCH }}" \
            --arg suffix "dev" \
            --arg name "Development" \
            --arg label "spot-dev-${dev_suffix}" \
            '. += [{"tag": $tag, "suffix": $suffix, "name": $name, "label": $label}]')
        fi

        # Scan LATEST if different from both DEV and PROD
        if [[ "${{ vars.OM_LATEST_RELEASE }}" != "${{ vars.DEV_RELEASE_BRANCH }}" && "${{ vars.OM_LATEST_RELEASE }}" != "${{ vars.PROD_RELEASE_BRANCH }}" ]]; then
          matrix_json=$(echo "$matrix_json" | jq --arg tag "${{ vars.OM_LATEST_RELEASE }}" \
            --arg suffix "latest" \
            --arg name "Latest" \
            --arg label "spot-latest-${latest_suffix}" \
            '. += [{"tag": $tag, "suffix": $suffix, "name": $name, "label": $label}]')
        fi
        echo "Generated matrix: $matrix_json"
        
        # Enhanced JSON validation with detailed debugging
        if echo "$matrix_json" | jq empty 2>/dev/null; then
          echo "âœ… JSON validation successful"
          echo "Matrix structure:"
          echo "$matrix_json" | jq .
          echo "Matrix items count: $(echo "$matrix_json" | jq length)"
          # Output compact JSON for GitHub Actions (single line, no formatting)
          compact_matrix=$(echo "$matrix_json" | jq -c .)
          echo "matrix=$compact_matrix" >> $GITHUB_OUTPUT
        else
          echo "âŒ JSON validation failed"
          echo "Invalid JSON: $matrix_json"
          echo "JSON error details:"
          echo "$matrix_json" | jq . 2>&1 || true
          echo "Environment variables:"
          echo "PROD_RELEASE_BRANCH: ${{ vars.PROD_RELEASE_BRANCH }}"
          echo "DEV_RELEASE_BRANCH: ${{ vars.DEV_RELEASE_BRANCH }}"
          echo "OM_LATEST_RELEASE: ${{ vars.OM_LATEST_RELEASE }}"
          exit 1
        fi

  # Debug matrix generation
  debug-matrix:
    needs: setup-matrix
    runs-on: ubuntu-latest
    steps:
    - name: Debug Matrix Output
      run: |
        echo "Matrix output from setup-matrix job:"
        echo '${{ needs.setup-matrix.outputs.matrix }}'
        echo "Parsing with jq:"
        echo '${{ needs.setup-matrix.outputs.matrix }}' | jq .
        echo "Matrix items count:"
        echo '${{ needs.setup-matrix.outputs.matrix }}' | jq length

  # Create spot VMs for each image scan
  create-spot:
    needs: [setup-matrix, debug-matrix]
    strategy:
      matrix:
        image: ${{ fromJson(needs.setup-matrix.outputs.matrix) }}
      fail-fast: false
      max-parallel: 0  # Explicitly allow unlimited parallel jobs
    uses: Jason-Clark-FG/azure-github-runner/.github/workflows/create.yml@main
    with:
      RESOURCE_GROUP_NAME: "rg-t-wus2-ghrunner-01"
      LOCATION: "westus2"
      VM_IMAGE: ${{ vars.VM_IMAGE_REF }}
      VM_SPOT: "True"
      VM_SIZE: "Standard_D8as_v5"
      VM_DISK_SIZE: "127"
      VM_NAME: "az-ghrunner-01t-spot-${{ matrix.image.suffix }}"
      VM_USERNAME: "ghradmin"
      STORAGE_BLOB_URI: "https://sfgdwus2syspro8.blob.core.windows.net/"
      SSH_KEY_BASENAME: id_rsa-${{ matrix.image.suffix }}
      RUNNER_LABEL: ${{ matrix.image.label }}
    secrets:
      ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
      ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
      GH_TOKEN: ${{ secrets.GH_TOKEN }}

  # Try to build on spot VMs
  build-spot:
    needs: [setup-matrix, debug-matrix, create-spot]
    strategy:
      matrix:
        image: ${{ fromJson(needs.setup-matrix.outputs.matrix) }}
      fail-fast: false
      max-parallel: 0  # Explicitly allow unlimited parallel jobs
    # Use a dynamic runner label based on the matrix suffix
    runs-on: ${{ matrix.image.label }}
    timeout-minutes: 120
    outputs:
      success-prod: ${{ matrix.image.suffix == 'prod' && steps.mark-success.outputs.success || '' }}
      success-dev: ${{ matrix.image.suffix == 'dev' && steps.mark-success.outputs.success || '' }}
      success-latest: ${{ matrix.image.suffix == 'latest' && steps.mark-success.outputs.success || '' }}
    permissions:
      security-events: write
      actions: read
      contents: read
      packages: write

    steps:
    - name: Debug Parallel Execution
      run: |
        echo "ðŸš€ Starting parallel scan for ${{ matrix.image.name }} at $(date)"
        echo "Runner: $(hostname)"
        echo "Matrix suffix: ${{ matrix.image.suffix }}"

    - name: Checkout Self
      uses: actions/checkout@v4

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USER }}
        password: ${{ secrets.DOCKER_PAT }}

    - name: Show Info
      run: |
        echo "ðŸŸ¡ Running ${{ matrix.image.name }} scan on SPOT instance"
        echo "Image: ${{ env.IMAGE_REGISTRY_1 }}/${{ env.IMAGE_OWNER_1 }}/${{ env.IMAGE_NAME_2 }}:${{ matrix.image.tag }}"
        ls -lDR ${GITHUB_WORKSPACE} | grep ':$'
        df -h
        env | sort

    - name: Setup Docker buildx
      uses: docker/setup-buildx-action@v3

    - name: "Mend: Scan Image - ${{ matrix.image.name }}"
      id: mend-cli-scan
      if: ${{ github.event_name != 'pull_request_target' }}
      shell: bash
      run: |
        # Install Mend
        curl -fsSL https://downloads.mend.io/cli/linux_amd64/mend -o /usr/local/bin/mend && chmod +x /usr/local/bin/mend
        mend version

        # Create reports directory
        mkdir -p ./reports
        ls -laR ~/.mend || true
        df -h

        check_eviction_notice() {
          response=$(curl -s -m 5 -H "Metadata:true" "http://169.254.169.254/metadata/scheduledevents?api-version=2019-08-01" 2>/dev/null || echo '{}')
          if echo "$response" | jq -e '.Events[]? | select(.EventType == "Preempt")' > /dev/null 2>&1; then
            echo "âš ï¸  Spot eviction notice received!"
            return 0
          fi
          return 1
        }

        # Function to run mend with eviction monitoring
        run_mend_with_monitoring() {
          local image_ref="$1"
          local output_file="$2"

          echo "ðŸ” Starting ${{ matrix.image.name }} scan: $image_ref"

          # Start the scan in background
          mend image "$image_ref" --filename "$output_file" --format sarif --scope "*//DataCatalogue//*" &
          local mend_pid=$!

          # Monitor for eviction notices while scan runs
          while kill -0 $mend_pid 2>/dev/null; do
            if check_eviction_notice; then
              echo "ðŸ›‘ Spot eviction detected during ${{ matrix.image.name }} scan, terminating gracefully..."
              kill $mend_pid 2>/dev/null || true
              wait $mend_pid 2>/dev/null || true
              exit 1
            fi
            sleep 30
          done

          # Wait for scan to complete and get result
          wait $mend_pid
          return $?
        }

        # Run the scan with retries
        for ((tries=1;tries <= ${{ env.SCAN_RETRIES }};tries++)); do
          echo "ðŸ”„ ${{ matrix.image.name }} scan attempt $tries of ${{ env.SCAN_RETRIES }}"

          if run_mend_with_monitoring "${{ env.IMAGE_REGISTRY_1 }}/${{ env.IMAGE_OWNER_1 }}/${{ env.IMAGE_NAME_2 }}:${{ matrix.image.tag }}" "./reports/${{ env.IMAGE_NAME_2 }}-${{ matrix.image.tag }}.sarif"; then
            echo "âœ… ${{ matrix.image.name }} scan completed successfully!"
            break
          else
            echo "âŒ ${{ matrix.image.name }} scan failed (attempt $tries)"
            if [[ $tries -eq ${{ env.SCAN_RETRIES }} ]]; then
              echo "ðŸš¨ All retries exhausted for ${{ matrix.image.name }} scan"
              exit 1
            fi
            sleep 30
          fi

          ls -laR ~/.mend/logs || true
          df -h
        done

        echo "ðŸŽ‰ ${{ matrix.image.name }} scan completed successfully"
        ls -laR ~/.mend/logs || true
        df -h
      env:
        MEND_URL: ${{ vars.MEND_URL }}
        MEND_EMAIL: ${{ secrets.MEND_EMAIL }}
        MEND_USER_KEY: ${{ secrets.MEND_USER_KEY }}
        MEND_LOG_LEVEL: DEBUG

    - name: SARIF Multitool
      id: sarif-multitool
      uses: microsoft/sarif-actions@v0.1
      with:
        command: merge ./reports/*.sarif --recurse true --output-directory=./reports/ --output-file=MendResults-${{ matrix.image.suffix }}.sarif

    - name: "Mend: Upload SARIF results - ${{ matrix.image.name }}"
      id: upload-sarif
      if: ${{ github.event_name != 'pull_request_target' && env.REPORTS_OUT == 'true' }}
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: './reports/MendResults-${{ matrix.image.suffix }}.sarif'
        wait-for-processing: false

    - name: "Mend: Upload logs - ${{ matrix.image.name }}"
      uses: actions/upload-artifact@v4
      with:
        name: mend_io_cn_scan_logs_spot_${{ matrix.image.suffix }}
        path: ~/.mend/logs/cn/*.log

    - name: Mark Success
      id: mark-success
      run: echo "success=true" >> $GITHUB_OUTPUT

  # Cleanup spot VMs (always run)
  delete-spot:
    needs: [setup-matrix, debug-matrix, build-spot, create-spot]
    if: ${{ always() }}
    strategy:
      matrix:
        image: ${{ fromJson(needs.setup-matrix.outputs.matrix) }}
      fail-fast: false
    uses: Jason-Clark-FG/azure-github-runner/.github/workflows/delete.yml@main
    with:
      RESOURCE_GROUP_NAME: "rg-t-wus2-ghrunner-01"
      VM_NAME: "az-ghrunner-01t-spot-${{ matrix.image.suffix }}"
      VM_USERNAME: "ghradmin"
      SSH_KEY_BASENAME: id_rsa-${{ matrix.image.suffix }}
    secrets:
      ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
      ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
      GH_TOKEN: ${{ secrets.GH_TOKEN }}

  # Determine which scans failed and need retry on regular VMs
  check-failures:
    needs: [setup-matrix, debug-matrix, build-spot]
    runs-on: ubuntu-latest
    if: ${{ always() }}
    outputs:
      failed-matrix: ${{ steps.failed.outputs.matrix }}
    steps:
    - name: Determine Failed Scans
      id: failed
      run: |
        original_matrix='${{ needs.setup-matrix.outputs.matrix }}'
        echo "Original matrix: $original_matrix"
        
        # Initialize empty array for failed items
        failed_matrix=$(jq -n '[]')
        
        # Check each matrix item to see if it failed
        while IFS= read -r item; do
          suffix=$(echo "$item" | jq -r '.suffix')

          # Check if this specific matrix job failed
          # Note: This is simplified - in practice you'd need to check the specific matrix job result
          echo "Checking $suffix scan result..."

          # For now, we'll assume any job that didn't complete successfully needs retry
          # You might need to adjust this logic based on how GitHub Actions exposes matrix job results
          failed_matrix=$(echo "$failed_matrix" | jq --argjson item "$item" '. += [$item]')
        done < <(echo "$original_matrix" | jq -c '.[]')

        # Validate and output the final matrix
        if echo "$failed_matrix" | jq empty 2>/dev/null; then
          echo "âœ… Failed matrix JSON validation successful"
          echo "Failed scans matrix: $failed_matrix"
          echo "Failed items count: $(echo "$failed_matrix" | jq length)"
          # Output compact JSON for GitHub Actions (single line, no formatting)
          compact_failed_matrix=$(echo "$failed_matrix" | jq -c .)
          echo "matrix=$compact_failed_matrix" >> $GITHUB_OUTPUT
        else
          echo "âŒ Failed matrix JSON validation failed"
          echo "Invalid JSON: $failed_matrix"
          echo "JSON error details:"
          echo "$failed_matrix" | jq . 2>&1 || true
          exit 1
        fi

  # Create regular VMs for failed scans
  create-regular:
    needs: [check-failures, delete-spot]
    if: ${{ always() && needs.check-failures.outputs.failed-matrix != '[]' }}
    strategy:
      matrix:
        image: ${{ fromJson(needs.check-failures.outputs.failed-matrix) }}
      fail-fast: false
    uses: Jason-Clark-FG/azure-github-runner/.github/workflows/create.yml@main
    with:
      RESOURCE_GROUP_NAME: "rg-t-wus2-ghrunner-01"
      LOCATION: "westus2"
      VM_IMAGE: ${{ vars.VM_IMAGE_REF }}
      VM_SPOT: "False"  # Regular instance
      VM_SIZE: "Standard_D8as_v5"
      VM_DISK_SIZE: "127"
      VM_NAME: "az-ghrunner-01t-regular-${{ matrix.image.suffix }}"
      VM_USERNAME: "ghradmin"
      STORAGE_BLOB_URI: "https://sfgdwus2syspro8.blob.core.windows.net/"
      SSH_KEY_BASENAME: id_rsa-${{ matrix.image.suffix }}
      RUNNER_LABEL: ${{ matrix.image.label }}
    secrets:
      ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
      ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
      GH_TOKEN: ${{ secrets.GH_TOKEN }}

  # Retry failed scans on regular VMs
  build-regular:
    needs: [check-failures, create-regular]
    if: ${{ needs.create-regular.result == 'success' }}
    strategy:
      matrix:
        image: ${{ fromJson(needs.check-failures.outputs.failed-matrix) }}
      fail-fast: false
    runs-on: ${{ matrix.image.label }}
    timeout-minutes: 120
    permissions:
      security-events: write
      actions: read
      contents: read
      packages: write

    steps:
    - name: Checkout Self
      uses: actions/checkout@v4

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USER }}
        password: ${{ secrets.DOCKER_PAT }}

    - name: Show Info
      run: |
        echo "ðŸŸ¢ Running ${{ matrix.image.name }} scan on REGULAR instance (spot failed)"
        echo "Image: ${{ env.IMAGE_REGISTRY_1 }}/${{ env.IMAGE_OWNER_1 }}/${{ env.IMAGE_NAME_2 }}:${{ matrix.image.tag }}"
        df -h

    - name: Setup Docker buildx
      uses: docker/setup-buildx-action@v3

    - name: "Mend: Scan Image - ${{ matrix.image.name }} (Retry)"
      id: mend-cli-scan
      if: ${{ github.event_name != 'pull_request_target' }}
      shell: bash
      run: |
        # Install Mend
        curl -fsSL https://downloads.mend.io/cli/linux_amd64/mend -o /usr/local/bin/mend && chmod +x /usr/local/bin/mend
        mend version

        # Create reports directory
        mkdir -p ./reports

        # Run the scan with retries (simpler version for regular VM)
        for ((tries=1;tries <= ${{ env.SCAN_RETRIES }};tries++)); do
          echo "ðŸ”„ ${{ matrix.image.name }} RETRY scan attempt $tries of ${{ env.SCAN_RETRIES }}"

          if mend image "${{ env.IMAGE_REGISTRY_1 }}/${{ env.IMAGE_OWNER_1 }}/${{ env.IMAGE_NAME_2 }}:${{ matrix.image.tag }}" --filename "./reports/${{ env.IMAGE_NAME_2 }}-${{ matrix.image.tag }}.sarif" --format sarif --scope "*//DataCatalogue//*"; then
            echo "âœ… ${{ matrix.image.name }} RETRY scan completed successfully!"
            break
          else
            echo "âŒ ${{ matrix.image.name }} RETRY scan failed (attempt $tries)"
            if [[ $tries -eq ${{ env.SCAN_RETRIES }} ]]; then
              echo "ðŸš¨ All RETRY attempts exhausted for ${{ matrix.image.name }} scan"
              exit 1
            fi
            sleep 30
          fi
        done
      env:
        MEND_URL: ${{ vars.MEND_URL }}
        MEND_EMAIL: ${{ secrets.MEND_EMAIL }}
        MEND_USER_KEY: ${{ secrets.MEND_USER_KEY }}
        MEND_LOG_LEVEL: DEBUG

    - name: SARIF Multitool
      uses: microsoft/sarif-actions@v0.1
      with:
        command: merge ./reports/*.sarif --recurse true --output-directory=./reports/ --output-file=MendResults-${{ matrix.image.suffix }}.sarif

    - name: "Mend: Upload SARIF results - ${{ matrix.image.name }} (Retry)"
      if: ${{ github.event_name != 'pull_request_target' && env.REPORTS_OUT == 'true' }}
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: './reports/MendResults-${{ matrix.image.suffix }}.sarif'
        wait-for-processing: false

    - name: "Mend: Upload logs - ${{ matrix.image.name }} (Retry)"
      uses: actions/upload-artifact@v4
      with:
        name: mend_io_cn_scan_logs_regular_${{ matrix.image.suffix }}
        path: ~/.mend/logs/cn/*.log

  # Cleanup regular VMs
  delete-regular:
    needs: [check-failures, build-regular, create-regular]
    if: ${{ always() && needs.create-regular.result == 'success' }}
    strategy:
      matrix:
        image: ${{ fromJson(needs.check-failures.outputs.failed-matrix) }}
      fail-fast: false
    uses: Jason-Clark-FG/azure-github-runner/.github/workflows/delete.yml@main
    with:
      RESOURCE_GROUP_NAME: "rg-t-wus2-ghrunner-01"
      VM_NAME: "az-ghrunner-01t-regular-${{ matrix.image.suffix }}"
      VM_USERNAME: "ghradmin"
      SSH_KEY_BASENAME: id_rsa-${{ matrix.image.suffix }}
    secrets:
      ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
      ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
      GH_TOKEN: ${{ secrets.GH_TOKEN }}
