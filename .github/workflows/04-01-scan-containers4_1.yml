name: "Worker: Step 4.1.4.1 - Scan Containers"

on:
  workflow_run:
    workflows: ["Worker: Step 3 - Modify Work Repo Matrix"]
    types:
      - completed
  workflow_dispatch:
    inputs:
      use_spot_vms:
        description: 'Use spot VMs (uncheck for regular VMs)'
        required: false
        type: boolean
        default: true
      vm_size:
        description: 'VM Size'
        required: false
        type: choice
        default: 'Standard_D4as_v5'
        options:
          - 'Standard_D4as_v5'
          - 'Standard_F8s_v2'
          - 'Standard_D8as_v5'

env:
  IMAGE_REGISTRY_1: docker.getcollate.io
  IMAGE_REGISTRY_2: docker.elastic.co
  IMAGE_OWNER_1: openmetadata
  IMAGE_OWNER_2: elasticsearch
  IMAGE_NAME_1: db
  IMAGE_NAME_2: ingestion
  IMAGE_NAME_3: server
  IMAGE_NAME_4: elasticsearch
  IMAGE_TAG_1: "1.1.6"
  IMAGE_TAG_2: "7.16.3"
  SCAN_RETRIES: 4
  REPORTS_OUT: false

jobs:
  # Determine which images need to be scanned
  setup-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.matrix.outputs.matrix }}
      use_spot: ${{ steps.config.outputs.use_spot }}
      vm_size: ${{ steps.config.outputs.vm_size }}
    steps:
    - name: Determine VM Configuration
      id: config
      run: |
        # Determine VM configuration based on trigger type
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          # Manual trigger - use user inputs or safer defaults
          use_spot="${{ github.event.inputs.use_spot_vms }}"
          vm_size="${{ github.event.inputs.vm_size }}"

          # Default to smaller, more stable VM if not specified
          if [[ -z "$vm_size" ]]; then
            vm_size="Standard_D4as_v5"
          fi

          # Handle spot VM option - GitHub Actions passes unchecked booleans as empty string
          # Only use spot VMs if explicitly set to "true"
          if [[ "$use_spot" == "true" ]]; then
            use_spot="true"
            echo "Manual dispatch: Using spot VMs with size $vm_size"
          else
            use_spot="false"
            echo "Manual dispatch: Using regular VMs with size $vm_size"
          fi
        else
          # Automated trigger (workflow_run) - use larger spot VMs for better performance
          use_spot="true"
          vm_size="Standard_F8s_v2"
          echo "Automated workflow_run trigger: Using larger spot VMs with size $vm_size for better performance"
        fi

        echo "use_spot=$use_spot" >> $GITHUB_OUTPUT
        echo "vm_size=$vm_size" >> $GITHUB_OUTPUT

    - name: Generate Matrix
      id: matrix
      run: |
        matrix_items=()

        # Generate random suffix for labels
        prod_suffix=$(shuf -er -n8 {a..z} | paste -sd '')
        dev_suffix=$(shuf -er -n8 {a..z} | paste -sd '')
        latest_suffix=$(shuf -er -n8 {a..z} | paste -sd '')

        # Build JSON array using jq for proper escaping
        matrix_json=$(jq -n '[]')

        # Always scan PROD
        matrix_json=$(echo "$matrix_json" | jq --arg tag "${{ vars.PROD_RELEASE_BRANCH }}" \
          --arg suffix "prod" \
          --arg name "Production" \
          --arg label "spot-prod-${prod_suffix}" \
          '. += [{"tag": $tag, "suffix": $suffix, "name": $name, "label": $label}]')

        # Scan DEV if different from PROD
        if [[ "${{ vars.DEV_RELEASE_BRANCH }}" != "${{ vars.PROD_RELEASE_BRANCH }}" ]]; then
          matrix_json=$(echo "$matrix_json" | jq --arg tag "${{ vars.DEV_RELEASE_BRANCH }}" \
            --arg suffix "dev" \
            --arg name "Development" \
            --arg label "spot-dev-${dev_suffix}" \
            '. += [{"tag": $tag, "suffix": $suffix, "name": $name, "label": $label}]')
        fi

        # Scan LATEST if different from both DEV and PROD
        if [[ "${{ vars.OM_LATEST_RELEASE }}" != "${{ vars.DEV_RELEASE_BRANCH }}" && "${{ vars.OM_LATEST_RELEASE }}" != "${{ vars.PROD_RELEASE_BRANCH }}" ]]; then
          matrix_json=$(echo "$matrix_json" | jq --arg tag "${{ vars.OM_LATEST_RELEASE }}" \
            --arg suffix "latest" \
            --arg name "Latest" \
            --arg label "spot-latest-${latest_suffix}" \
            '. += [{"tag": $tag, "suffix": $suffix, "name": $name, "label": $label}]')
        fi
        echo "Generated matrix: $matrix_json"

        # Enhanced JSON validation with detailed debugging
        if echo "$matrix_json" | jq empty 2>/dev/null; then
          echo "‚úÖ JSON validation successful"
          echo "Matrix structure:"
          echo "$matrix_json" | jq .
          echo "Matrix items count: $(echo "$matrix_json" | jq length)"
          # Output compact JSON for GitHub Actions (single line, no formatting)
          compact_matrix=$(echo "$matrix_json" | jq -c .)
          echo "matrix=$compact_matrix" >> $GITHUB_OUTPUT
        else
          echo "‚ùå JSON validation failed"
          echo "Invalid JSON: $matrix_json"
          echo "JSON error details:"
          echo "$matrix_json" | jq . 2>&1 || true
          echo "Environment variables:"
          echo "PROD_RELEASE_BRANCH: ${{ vars.PROD_RELEASE_BRANCH }}"
          echo "DEV_RELEASE_BRANCH: ${{ vars.DEV_RELEASE_BRANCH }}"
          echo "OM_LATEST_RELEASE: ${{ vars.OM_LATEST_RELEASE }}"
          exit 1
        fi

  # Debug matrix generation
  debug-matrix:
    needs: setup-matrix
    runs-on: ubuntu-latest
    steps:
    - name: Debug Matrix Output
      run: |
        echo "Matrix output from setup-matrix job:"
        echo '${{ needs.setup-matrix.outputs.matrix }}'
        echo "VM Configuration:"
        echo "Use Spot: ${{ needs.setup-matrix.outputs.use_spot }}"
        echo "VM Size: ${{ needs.setup-matrix.outputs.vm_size }}"
        echo "Parsing with jq:"
        echo '${{ needs.setup-matrix.outputs.matrix }}' | jq .
        echo "Matrix items count:"
        echo '${{ needs.setup-matrix.outputs.matrix }}' | jq length

  # Create VMs for each image scan (spot or regular based on configuration)
  create-vms:
    needs: [setup-matrix, debug-matrix]
    strategy:
      matrix:
        image: ${{ fromJson(needs.setup-matrix.outputs.matrix) }}
      fail-fast: false
      max-parallel: 0  # Explicitly allow unlimited parallel jobs
    uses: Jason-Clark-FG/azure-github-runner/.github/workflows/create.yml@main
    with:
      RESOURCE_GROUP_NAME: "rg-t-wus2-ghrunner-01"
      LOCATION: "westus2"
      VM_IMAGE: ${{ vars.VM_IMAGE_REF }}
      VM_SPOT: ${{ needs.setup-matrix.outputs.use_spot }}
      VM_SIZE: ${{ needs.setup-matrix.outputs.vm_size }}
      VM_DISK_SIZE: "127"
      VM_NAME: "az-ghrunner-01t-${{ needs.setup-matrix.outputs.use_spot == 'true' && 'spot' || 'regular' }}-${{ matrix.image.suffix }}"
      VM_USERNAME: "ghradmin"
      STORAGE_BLOB_URI: "https://sfgdwus2syspro8.blob.core.windows.net/"
      SSH_KEY_BASENAME: id_rsa-${{ matrix.image.suffix }}
      RUNNER_LABEL: ${{ matrix.image.label }}
    secrets:
      ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
      ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
      GH_TOKEN: ${{ secrets.GH_TOKEN }}

  # Build and scan images
  build-and-scan:
    needs: [setup-matrix, debug-matrix, create-vms]
    # Only run if not cancelled and ALL VM creation jobs succeeded
    if: ${{ !cancelled() && !contains(needs.create-vms.result, 'failure') && !contains(needs.create-vms.result, 'cancelled') }}
    strategy:
      matrix:
        image: ${{ fromJson(needs.setup-matrix.outputs.matrix) }}
      fail-fast: false
      max-parallel: 0  # Explicitly allow unlimited parallel jobs
    # Use a dynamic runner label based on the matrix suffix
    runs-on: ${{ matrix.image.label }}
    timeout-minutes: 180
    outputs:
      success-prod: ${{ matrix.image.suffix == 'prod' && steps.mark-success.outputs.success || '' }}
      success-dev: ${{ matrix.image.suffix == 'dev' && steps.mark-success.outputs.success || '' }}
      success-latest: ${{ matrix.image.suffix == 'latest' && steps.mark-success.outputs.success || '' }}
    permissions:
      security-events: write
      actions: read
      contents: read
      packages: write

    steps:
    - name: Check VM Creation Success
      run: |
        echo "Checking VM creation status..."
        echo "VM creation result: ${{ needs.create-vms.result }}"
        if [[ "${{ needs.create-vms.result }}" != "success" ]]; then
          echo "‚ùå VM creation failed or was cancelled. Cannot proceed with scanning."
          echo "This could be due to:"
          echo "  - Azure quota limits (vCPU, resource limits)"
          echo "  - Network connectivity issues"
          echo "  - Authentication problems"
          echo "  - Resource group issues"
          exit 1
        fi
        echo "‚úÖ VM creation successful, proceeding with scan"

    - name: Wait for Runner Registration
      timeout-minutes: 5  # Short timeout just for runner check
      run: |
        echo "üîç Verifying runner availability for ${{ matrix.image.name }} scan"
        echo "Runner: $(hostname)"
        echo "Matrix suffix: ${{ matrix.image.suffix }}"
        echo "Runner label: ${{ matrix.image.label }}"
        echo "VM Type: ${{ needs.setup-matrix.outputs.use_spot == 'true' && 'Spot' || 'Regular' }}"
        echo "VM Size: ${{ needs.setup-matrix.outputs.vm_size }}"
        echo "System ready at $(date)"

    - name: Debug Parallel Execution
      run: |
        echo "üöÄ Starting parallel scan for ${{ matrix.image.name }} at $(date)"
        echo "Runner: $(hostname)"
        echo "Matrix suffix: ${{ matrix.image.suffix }}"

    - name: Checkout Self
      uses: actions/checkout@v4

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USER }}
        password: ${{ secrets.DOCKER_PAT }}

    - name: Show Info
      run: |
        vm_type="${{ needs.setup-matrix.outputs.use_spot == 'true' && 'SPOT' || 'REGULAR' }}"
        echo "üü° Running ${{ matrix.image.name }} scan on $vm_type instance"
        echo "Image: ${{ env.IMAGE_REGISTRY_1 }}/${{ env.IMAGE_OWNER_1 }}/${{ env.IMAGE_NAME_2 }}:${{ matrix.image.tag }}"
        ls -lDR ${GITHUB_WORKSPACE} | grep ':$'
        df -h
        env | sort

    - name: Setup Docker buildx
      uses: docker/setup-buildx-action@v3

    - name: "Mend: Scan Image - ${{ matrix.image.name }}"
      id: mend-cli-scan
      if: ${{ github.event_name != 'pull_request_target' }}
      shell: bash
      run: |
        # Install Mend with proper error checking and directory creation
        echo "üîß Installing Mend CLI..."

        # Ensure destination directory exists and is writable
        sudo mkdir -p /usr/local/bin

        # Check if we have write permissions, create temp location if not
        if [[ ! -w /usr/local/bin ]]; then
          echo "‚ö†Ô∏è No write access to /usr/local/bin, using sudo for installation"
          temp_mend=$(mktemp)

          if curl -fsSL https://downloads.mend.io/cli/linux_amd64/mend -o "$temp_mend"; then
            sudo mv "$temp_mend" /usr/local/bin/mend
            sudo chmod +x /usr/local/bin/mend
            echo "‚úÖ Mend CLI installed successfully with sudo"
          else
            echo "‚ùå Failed to download Mend CLI"
            exit 1
          fi
        else
          # Direct installation
          if curl -fsSL https://downloads.mend.io/cli/linux_amd64/mend -o /usr/local/bin/mend; then
            chmod +x /usr/local/bin/mend
            echo "‚úÖ Mend CLI installed successfully"
          else
            echo "‚ùå Failed to download Mend CLI"
            exit 1
          fi
        fi

        # Verify installation
        echo "üîç Verifying Mend installation..."
        if command -v mend >/dev/null 2>&1; then
          mend version
          echo "‚úÖ Mend CLI is working properly"
        else
          echo "‚ùå Mend CLI installation verification failed"
          echo "PATH: $PATH"
          echo "Contents of /usr/local/bin:"
          ls -la /usr/local/bin/ | grep mend || echo "No mend binary found"
          exit 1
        fi

        # Create reports directory
        mkdir -p ./reports
        ls -laR ~/.mend || true
        df -h

        check_eviction_notice() {
          # Only check for eviction if using spot VMs
          if [[ "${{ needs.setup-matrix.outputs.use_spot }}" != "true" ]]; then
            return 1  # Not a spot VM, no eviction possible
          fi

          # Use curl with better error handling and timeout
          response=$(curl -s -m 5 -f --connect-timeout 3 --max-time 5 \
            -H "Metadata:true" \
            "http://169.254.169.254/metadata/scheduledevents?api-version=2019-08-01" \
            2>/dev/null || echo '{"Events":[]}')

          # Validate response is valid JSON before processing
          if echo "$response" | jq empty 2>/dev/null; then
            if echo "$response" | jq -e '.Events[]? | select(.EventType == "Preempt")' > /dev/null 2>&1; then
              echo "‚ö†Ô∏è Spot eviction notice received!"
              echo "Eviction details: $response"
              return 0
            fi
          else
            # If we can't reach metadata service or get invalid JSON, assume no eviction
            # This prevents false positives when metadata service is unreachable
            echo "üîç Unable to check eviction status (metadata service unreachable)"
          fi
          return 1
        }

        # Function to run mend with eviction monitoring
        run_mend_with_monitoring() {
          local image_ref="$1"
          local output_file="$2"

          echo "üîç Starting ${{ matrix.image.name }} scan: $image_ref"

          # Start the scan in background
          mend image "$image_ref" --filename "$output_file" --format sarif --scope "*//DataCatalogue//*" &
          local mend_pid=$!

          # Monitor for eviction notices while scan runs (only for spot VMs)
          if [[ "${{ needs.setup-matrix.outputs.use_spot }}" == "true" ]]; then
            while kill -0 $mend_pid 2>/dev/null; do
              if check_eviction_notice; then
                echo "üõë Spot eviction detected during ${{ matrix.image.name }} scan, terminating gracefully..."
                kill $mend_pid 2>/dev/null || true
                wait $mend_pid 2>/dev/null || true
                exit 1
              fi
              sleep 30
            done
          fi

          # Wait for scan to complete and get result
          wait $mend_pid
          return $?
        }

        # Run the scan with retries
        for ((tries=1;tries <= ${{ env.SCAN_RETRIES }};tries++)); do
          echo "üîÑ ${{ matrix.image.name }} scan attempt $tries of ${{ env.SCAN_RETRIES }}"

          if run_mend_with_monitoring "${{ env.IMAGE_REGISTRY_1 }}/${{ env.IMAGE_OWNER_1 }}/${{ env.IMAGE_NAME_2 }}:${{ matrix.image.tag }}" "./reports/${{ env.IMAGE_NAME_2 }}-${{ matrix.image.tag }}.sarif"; then
            echo "‚úÖ ${{ matrix.image.name }} scan completed successfully!"
            break
          else
            echo "‚ùå ${{ matrix.image.name }} scan failed (attempt $tries)"
            if [[ $tries -eq ${{ env.SCAN_RETRIES }} ]]; then
              echo "üö® All retries exhausted for ${{ matrix.image.name }} scan"
              exit 1
            fi
            sleep 30
          fi

          ls -laR ~/.mend/logs || true
          df -h
        done

        echo "üéâ ${{ matrix.image.name }} scan completed successfully"
        ls -laR ~/.mend/logs || true
        df -h
      env:
        MEND_URL: ${{ vars.MEND_URL }}
        MEND_EMAIL: ${{ secrets.MEND_EMAIL }}
        MEND_USER_KEY: ${{ secrets.MEND_USER_KEY }}
        MEND_LOG_LEVEL: DEBUG

    - name: SARIF Multitool
      id: sarif-multitool
      uses: microsoft/sarif-actions@v0.1
      with:
        command: merge ./reports/*.sarif --recurse true --output-directory=./reports/ --output-file=MendResults-${{ matrix.image.suffix }}.sarif

    - name: "Mend: Upload SARIF results - ${{ matrix.image.name }}"
      id: upload-sarif
      if: ${{ github.event_name != 'pull_request_target' && env.REPORTS_OUT == 'true' }}
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: './reports/MendResults-${{ matrix.image.suffix }}.sarif'
        wait-for-processing: false

    - name: "Mend: Upload logs - ${{ matrix.image.name }}"
      uses: actions/upload-artifact@v4
      with:
        name: mend_io_cn_scan_logs_${{ needs.setup-matrix.outputs.use_spot == 'true' && 'spot' || 'regular' }}_${{ matrix.image.suffix }}
        path: ~/.mend/logs/cn/*.log

    - name: Mark Success
      id: mark-success
      run: echo "success=true" >> $GITHUB_OUTPUT

  # Sequential cleanup VMs (wait for build jobs to complete first)
  cleanup-vms:
    needs: [setup-matrix, create-vms, build-and-scan]
    # Always run cleanup if VMs were created, regardless of build success/failure
    # This ensures cleanup happens even if builds fail or are cancelled
    if: ${{ always() && !contains(needs.create-vms.result, 'failure') && !contains(needs.create-vms.result, 'cancelled') && !contains(needs.create-vms.result, 'skipped') }}
    strategy:
      matrix:
        image: ${{ fromJson(needs.setup-matrix.outputs.matrix) }}
      fail-fast: false
      # Sequential cleanup to avoid race conditions and deletion conflicts
      max-parallel: 1
    uses: Jason-Clark-FG/azure-github-runner/.github/workflows/delete.yml@main
    with:
      RESOURCE_GROUP_NAME: "rg-t-wus2-ghrunner-01"
      VM_NAME: "az-ghrunner-01t-${{ needs.setup-matrix.outputs.use_spot == 'true' && 'spot' || 'regular' }}-${{ matrix.image.suffix }}"
      VM_USERNAME: "ghradmin"
      SSH_KEY_BASENAME: id_rsa-${{ matrix.image.suffix }}
    secrets:
      ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
      ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
      GH_TOKEN: ${{ secrets.GH_TOKEN }}

  # Emergency cleanup job that runs if the main cleanup fails or needs additional coverage
  emergency-cleanup:
    needs: [setup-matrix, create-vms, cleanup-vms]
    # Run if cleanup had any issues or if VMs were actually created (covers partial failures)
    if: ${{ always() && !contains(needs.create-vms.result, 'failure') && !contains(needs.create-vms.result, 'cancelled') && !contains(needs.create-vms.result, 'skipped') }}
    runs-on: ubuntu-latest
    steps:
    - name: Emergency VM Cleanup
      run: |
        echo "üö® Running emergency cleanup to ensure complete resource cleanup"
        echo "This runs after normal cleanup to catch any missed resources"

        # Install Azure CLI
        curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash

        # Login to Azure
        az login --service-principal \
          --username "${{ secrets.ARM_CLIENT_ID }}" \
          --password "${{ secrets.ARM_CLIENT_SECRET }}" \
          --tenant "${{ secrets.ARM_TENANT_ID }}"

        az account set --subscription "${{ secrets.ARM_SUBSCRIPTION_ID }}"

        resource_group="rg-t-wus2-ghrunner-01"

        # Check if resource group exists first
        if ! az group show --resource-group "$resource_group" --output none 2>/dev/null; then
          echo "‚úÖ Resource group $resource_group does not exist (already cleaned up)"
          exit 0
        fi

        echo "üîç Scanning resource group $resource_group for any remaining resources..."

        # Install GitHub CLI for force destroy option
        type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
        curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
        && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
        && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
        && sudo apt update \
        && sudo apt install gh -y

        # Clone the azure-github-runner repo to get the latest scripts
        git clone https://github.com/Jason-Clark-FG/azure-github-runner.git /tmp/azure-github-runner
        cd /tmp/azure-github-runner

        # Look for ANY VMs in the resource group that match our pattern
        echo "üîç Checking for VMs matching pattern 'az-ghrunner-01t-*'..."
        orphaned_vms=$(az vm list --resource-group "$resource_group" --query "[?starts_with(name, 'az-ghrunner-01t-')].name" -o tsv 2>/dev/null || true)

        if [[ -n "$orphaned_vms" ]]; then
          echo "Found VMs that need cleanup:"
          echo "$orphaned_vms" | while IFS= read -r vm_name; do
            if [[ -n "$vm_name" ]]; then
              echo "üóëÔ∏è Force destroying VM: $vm_name"

              # Use the enhanced main.sh with --force-destroy to skip SSH cleanup
              export GITHUB_REPO="${{ github.repository }}"
              export GH_TOKEN="${{ secrets.GH_TOKEN }}"
              export RUN_ID="${{ github.run_id }}"
              export RESOURCE_GROUP_NAME="$resource_group"
              export VM_NAME="$vm_name"
              export VM_USERNAME="ghradmin"

              # Use force destroy to skip problematic SSH cleanup
              if ./main.sh --force-destroy 2>/dev/null; then
                echo "‚úÖ Successfully force destroyed VM: $vm_name"
              else
                echo "‚ö†Ô∏è Force destroy script failed for $vm_name, falling back to direct deletion"

                # Fallback: direct Azure CLI deletion
                az vm delete --resource-group "$resource_group" --name "$vm_name" --yes --no-wait 2>/dev/null || echo "Direct VM deletion also failed"
              fi
            fi
          done
        else
          echo "‚úÖ No VMs found matching pattern 'az-ghrunner-01t-*'"
        fi

        # Additional manual cleanup for any remaining resources
        echo ""
        echo "üßπ Scanning for other orphaned resources..."

        # Clean up any remaining orphaned resources by pattern
        resource_types=(
          "vm:az-ghrunner-01t-"
          "disk:az-ghrunner-01t-"
          "network nic:az-ghrunner-01t-"
          "network public-ip:az-ghrunner-01t-"
          "network nsg:az-ghrunner-01t-"
        )

        for resource_spec in "${resource_types[@]}"; do
          IFS=':' read -r resource_type pattern <<< "$resource_spec"

          echo "Checking for ${resource_type} resources with pattern: ${pattern}*"

          case "$resource_type" in
            "vm")
              resources=$(az vm list --resource-group "$resource_group" --query "[?starts_with(name, '${pattern}')].name" -o tsv 2>/dev/null || true)
              ;;
            "disk")
              resources=$(az disk list --resource-group "$resource_group" --query "[?starts_with(name, '${pattern}')].name" -o tsv 2>/dev/null || true)
              ;;
            "network nic")
              resources=$(az network nic list --resource-group "$resource_group" --query "[?starts_with(name, '${pattern}')].name" -o tsv 2>/dev/null || true)
              ;;
            "network public-ip")
              resources=$(az network public-ip list --resource-group "$resource_group" --query "[?starts_with(name, '${pattern}')].name" -o tsv 2>/dev/null || true)
              ;;
            "network nsg")
              resources=$(az network nsg list --resource-group "$resource_group" --query "[?starts_with(name, '${pattern}')].name" -o tsv 2>/dev/null || true)
              ;;
          esac

          if [[ -n "$resources" ]]; then
            echo "Found orphaned ${resource_type} resources:"
            echo "$resources" | while IFS= read -r resource; do
              if [[ -n "$resource" ]]; then
                echo "  üóëÔ∏è Deleting: $resource"
                az $resource_type delete --resource-group "$resource_group" --name "$resource" --yes --no-wait 2>/dev/null || echo "    ‚ö†Ô∏è Failed to delete $resource"
              fi
            done
          fi
        done

        echo ""
        echo "‚úÖ Emergency cleanup scan completed"

        # Give Azure some time to process deletions before RG cleanup
        echo "‚è≥ Waiting 60 seconds for Azure to process resource deletions..."
        sleep 60

  # Optional: Determine which scans failed and need retry (only if using spot VMs and they failed)
  check-spot-failures:
    needs: [setup-matrix, build-and-scan]
    runs-on: ubuntu-latest
    # Only check for failures if we were using spot VMs and some jobs failed
    if: ${{ always() && needs.setup-matrix.outputs.use_spot == 'true' && contains(needs.build-and-scan.result, 'failure') }}
    outputs:
      failed-matrix: ${{ steps.failed.outputs.matrix }}
      has-failures: ${{ steps.failed.outputs.has-failures }}
    steps:
    - name: Determine Failed Spot Scans
      id: failed
      run: |
        echo "Checking for failed spot VM scans that need retry on regular VMs..."

        original_matrix='${{ needs.setup-matrix.outputs.matrix }}'
        echo "Original matrix: $original_matrix"

        # For now, create a simplified failed matrix
        # In a real scenario, you'd need more sophisticated logic to determine which specific matrix jobs failed
        failed_matrix=$(echo "$original_matrix")

        # Check if we have any failures
        if [[ "$(echo "$failed_matrix" | jq length)" -gt 0 ]]; then
          echo "has-failures=true" >> $GITHUB_OUTPUT
          compact_failed_matrix=$(echo "$failed_matrix" | jq -c .)
          echo "matrix=$compact_failed_matrix" >> $GITHUB_OUTPUT
          echo "Found failed scans that need retry: $compact_failed_matrix"
        else
          echo "has-failures=false" >> $GITHUB_OUTPUT
          echo "matrix=[]" >> $GITHUB_OUTPUT
          echo "No failed scans found"
        fi

  # Create regular VMs for failed spot scans (only if spot failed and we're not cancelled)
  create-retry-vms:
    needs: [check-spot-failures, cleanup-vms, emergency-cleanup]
    if: ${{ !cancelled() && needs.check-spot-failures.outputs.has-failures == 'true' && (needs.cleanup-vms.result == 'success' || needs.emergency-cleanup.result == 'success') }}
    strategy:
      matrix:
        image: ${{ fromJson(needs.check-spot-failures.outputs.failed-matrix) }}
      fail-fast: false
    uses: Jason-Clark-FG/azure-github-runner/.github/workflows/create.yml@main
    with:
      RESOURCE_GROUP_NAME: "rg-t-wus2-ghrunner-01"
      LOCATION: "westus2"
      VM_IMAGE: ${{ vars.VM_IMAGE_REF }}
      VM_SPOT: "False"  # Always use regular instances for retries
      VM_SIZE: "Standard_D4as_v5"  # Use smaller, more stable size for retries
      VM_DISK_SIZE: "127"
      VM_NAME: "az-ghrunner-01t-retry-${{ matrix.image.suffix }}"
      VM_USERNAME: "ghradmin"
      STORAGE_BLOB_URI: "https://sfgdwus2syspro8.blob.core.windows.net/"
      SSH_KEY_BASENAME: id_rsa-retry-${{ matrix.image.suffix }}
      RUNNER_LABEL: retry-${{ matrix.image.label }}
    secrets:
      ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
      ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
      GH_TOKEN: ${{ secrets.GH_TOKEN }}

  # Retry failed scans on regular VMs
  retry-on-regular:
    needs: [check-spot-failures, create-retry-vms]
    if: ${{ !cancelled() && needs.create-retry-vms.result == 'success' }}
    strategy:
      matrix:
        image: ${{ fromJson(needs.check-spot-failures.outputs.failed-matrix) }}
      fail-fast: false
    runs-on: retry-${{ matrix.image.label }}
    timeout-minutes: 180
    permissions:
      security-events: write
      actions: read
      contents: read
      packages: write

    steps:
    - name: Checkout Self
      uses: actions/checkout@v4

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USER }}
        password: ${{ secrets.DOCKER_PAT }}

    - name: Show Info
      run: |
        echo "üü¢ Running ${{ matrix.image.name }} scan on REGULAR instance (spot retry)"
        echo "Image: ${{ env.IMAGE_REGISTRY_1 }}/${{ env.IMAGE_OWNER_1 }}/${{ env.IMAGE_NAME_2 }}:${{ matrix.image.tag }}"
        df -h

    - name: Setup Docker buildx
      uses: docker/setup-buildx-action@v3

    - name: "Mend: Scan Image - ${{ matrix.image.name }} (Retry)"
      id: mend-cli-scan
      if: ${{ github.event_name != 'pull_request_target' }}
      shell: bash
      run: |
        # Install Mend with proper error checking
        echo "üîß Installing Mend CLI for retry scan..."

        # Ensure destination directory exists and is writable
        sudo mkdir -p /usr/local/bin

        # Check if we have write permissions, create temp location if not
        if [[ ! -w /usr/local/bin ]]; then
          echo "‚ö†Ô∏è No write access to /usr/local/bin, using sudo for installation"
          temp_mend=$(mktemp)

          if curl -fsSL https://downloads.mend.io/cli/linux_amd64/mend -o "$temp_mend"; then
            sudo mv "$temp_mend" /usr/local/bin/mend
            sudo chmod +x /usr/local/bin/mend
            echo "‚úÖ Mend CLI installed successfully with sudo"
          else
            echo "‚ùå Failed to download Mend CLI"
            exit 1
          fi
        else
          # Direct installation
          if curl -fsSL https://downloads.mend.io/cli/linux_amd64/mend -o /usr/local/bin/mend; then
            chmod +x /usr/local/bin/mend
            echo "‚úÖ Mend CLI installed successfully"
          else
            echo "‚ùå Failed to download Mend CLI"
            exit 1
          fi
        fi

        # Verify installation
        echo "üîç Verifying Mend installation..."
        if command -v mend >/dev/null 2>&1; then
          mend version
          echo "‚úÖ Mend CLI is working properly"
        else
          echo "‚ùå Mend CLI installation verification failed"
          echo "PATH: $PATH"
          echo "Contents of /usr/local/bin:"
          ls -la /usr/local/bin/ | grep mend || echo "No mend binary found"
          exit 1
        fi

        # Create reports directory
        mkdir -p ./reports

        # Run the scan with retries (simpler version for regular VM)
        for ((tries=1;tries <= ${{ env.SCAN_RETRIES }};tries++)); do
          echo "üîÑ ${{ matrix.image.name }} RETRY scan attempt $tries of ${{ env.SCAN_RETRIES }}"

          if mend image "${{ env.IMAGE_REGISTRY_1 }}/${{ env.IMAGE_OWNER_1 }}/${{ env.IMAGE_NAME_2 }}:${{ matrix.image.tag }}" --filename "./reports/${{ env.IMAGE_NAME_2 }}-${{ matrix.image.tag }}.sarif" --format sarif --scope "*//DataCatalogue//*"; then
            echo "‚úÖ ${{ matrix.image.name }} RETRY scan completed successfully!"
            break
          else
            echo "‚ùå ${{ matrix.image.name }} RETRY scan failed (attempt $tries)"
            if [[ $tries -eq ${{ env.SCAN_RETRIES }} ]]; then
              echo "üö® All RETRY attempts exhausted for ${{ matrix.image.name }} scan"
              exit 1
            fi
            sleep 30
          fi
        done
      env:
        MEND_URL: ${{ vars.MEND_URL }}
        MEND_EMAIL: ${{ secrets.MEND_EMAIL }}
        MEND_USER_KEY: ${{ secrets.MEND_USER_KEY }}
        MEND_LOG_LEVEL: DEBUG

    - name: SARIF Multitool
      uses: microsoft/sarif-actions@v0.1
      with:
        command: merge ./reports/*.sarif --recurse true --output-directory=./reports/ --output-file=MendResults-retry-${{ matrix.image.suffix }}.sarif

    - name: "Mend: Upload SARIF results - ${{ matrix.image.name }} (Retry)"
      if: ${{ github.event_name != 'pull_request_target' && env.REPORTS_OUT == 'true' }}
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: './reports/MendResults-retry-${{ matrix.image.suffix }}.sarif'
        wait-for-processing: false

    - name: "Mend: Upload logs - ${{ matrix.image.name }} (Retry)"
      uses: actions/upload-artifact@v4
      with:
        name: mend_io_cn_scan_logs_retry_${{ matrix.image.suffix }}
        path: ~/.mend/logs/cn/*.log

  # Final cleanup of retry VMs
  cleanup-retry-vms:
    needs: [check-spot-failures, create-retry-vms, retry-on-regular]
    if: ${{ always() && !contains(needs.create-retry-vms.result, 'failure') && !contains(needs.create-retry-vms.result, 'cancelled') && !contains(needs.create-retry-vms.result, 'skipped') }}
    strategy:
      matrix:
        image: ${{ fromJson(needs.check-spot-failures.outputs.failed-matrix) }}
      fail-fast: false
      max-parallel: 1  # Sequential cleanup
    uses: Jason-Clark-FG/azure-github-runner/.github/workflows/delete.yml@main
    with:
      RESOURCE_GROUP_NAME: "rg-t-wus2-ghrunner-01"
      VM_NAME: "az-ghrunner-01t-retry-${{ matrix.image.suffix }}"
      VM_USERNAME: "ghradmin"
      SSH_KEY_BASENAME: id_rsa-retry-${{ matrix.image.suffix }}
    secrets:
      ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
      ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
      GH_TOKEN: ${{ secrets.GH_TOKEN }}

  # Final resource group cleanup (after all VMs are deleted)
  cleanup-resource-group:
    needs: [setup-matrix, create-vms, cleanup-vms, emergency-cleanup, cleanup-retry-vms]
    # Only run if we created VMs and either normal cleanup succeeded or emergency cleanup ran
    if: ${{ always() && !contains(needs.create-vms.result, 'failure') && !contains(needs.create-vms.result, 'cancelled') && (needs.cleanup-vms.result == 'success' || needs.emergency-cleanup.result == 'success' || needs.cleanup-retry-vms.result == 'success') }}
    runs-on: ubuntu-latest
    steps:
    - name: Delete Resource Group
      run: |
        echo "üßπ Final cleanup: Deleting resource group after all VMs are cleaned up"

        # Install Azure CLI
        curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash

        # Login to Azure
        az login --service-principal \
          --username "${{ secrets.ARM_CLIENT_ID }}" \
          --password "${{ secrets.ARM_CLIENT_SECRET }}" \
          --tenant "${{ secrets.ARM_TENANT_ID }}"

        az account set --subscription "${{ secrets.ARM_SUBSCRIPTION_ID }}"

        resource_group="rg-t-wus2-ghrunner-01"

        # Check if resource group exists
        if az group show --resource-group "$resource_group" --output none 2>/dev/null; then
          echo "üìä Checking remaining resources before RG deletion..."
          remaining_resources=$(az resource list --resource-group "$resource_group" --query "length(@)" 2>/dev/null || echo "0")

          if [[ "$remaining_resources" -gt 0 ]]; then
            echo "‚ö†Ô∏è  Found $remaining_resources remaining resources in RG:"
            az resource list --resource-group "$resource_group" --query "[].{Name:name, Type:type}" --output table 2>/dev/null || true
            echo "Proceeding with RG deletion anyway (will clean up all remaining resources)..."
          else
            echo "‚úÖ Resource group is empty, safe to delete"
          fi

          echo "üóëÔ∏è Deleting resource group: $resource_group"
          if az group delete --resource-group "$resource_group" --yes --no-wait; then
            echo "‚úÖ Successfully initiated deletion of resource group: $resource_group"
            echo "üïê Resource group deletion is running in the background"
          else
            echo "‚ùå Failed to delete resource group: $resource_group"
            echo "Manual cleanup required:"
            echo "  az group delete --resource-group $resource_group --yes"
            exit 1
          fi
        else
          echo "‚úÖ Resource group $resource_group does not exist (already cleaned up)"
        fi

  # Final status report
  workflow-summary:
    needs: [setup-matrix, create-vms, build-and-scan, cleanup-vms, emergency-cleanup, check-spot-failures, create-retry-vms, retry-on-regular, cleanup-retry-vms, cleanup-resource-group]
    if: ${{ always() }}
    runs-on: ubuntu-latest
    steps:
    - name: Workflow Summary
      run: |
        echo "üîç Container Scan Workflow Summary"
        echo "=================================="
        echo "VM Configuration:"
        echo "  - Use Spot: ${{ needs.setup-matrix.outputs.use_spot }}"
        echo "  - VM Size: ${{ needs.setup-matrix.outputs.vm_size }}"
        echo "  - Trigger: ${{ github.event_name }}"
        echo ""
        echo "Job Results:"
        echo "  - setup-matrix: ${{ needs.setup-matrix.result }}"
        echo "  - create-vms: ${{ needs.create-vms.result }}"
        echo "  - build-and-scan: ${{ needs.build-and-scan.result }}"
        echo "  - cleanup-vms: ${{ needs.cleanup-vms.result }}"
        echo "  - emergency-cleanup: ${{ needs.emergency-cleanup.result }}"
        echo "  - check-spot-failures: ${{ needs.check-spot-failures.result }}"
        echo "  - create-retry-vms: ${{ needs.create-retry-vms.result }}"
        echo "  - retry-on-regular: ${{ needs.retry-on-regular.result }}"
        echo "  - cleanup-retry-vms: ${{ needs.cleanup-retry-vms.result }}"
        echo "  - cleanup-resource-group: ${{ needs.cleanup-resource-group.result }}"
        echo ""

        # Check for potential issues
        if [[ "${{ needs.create-vms.result }}" == "failure" ]]; then
          echo "‚ö†Ô∏è  VM Creation Failed - Possible Issues:"
          echo "  - Azure quota exceeded (check vCPU limits)"
          echo "  - Network connectivity problems"
          echo "  - Authentication issues"
          echo "  - Resource group access problems"
        fi

        if [[ "${{ needs.cleanup-vms.result }}" == "failure" ]]; then
          echo "‚ö†Ô∏è  VM Cleanup Failed:"
          echo "  - Check emergency cleanup results"
          echo "  - Manual cleanup may be required"
          echo "  - Verify GH_TOKEN permissions"
        fi

        if [[ "${{ needs.emergency-cleanup.result }}" == "success" ]]; then
          echo "‚úÖ Emergency cleanup was successful"
        elif [[ "${{ needs.emergency-cleanup.result }}" == "failure" ]]; then
          echo "üö® Emergency cleanup also failed - manual intervention required"
        fi

        echo ""
        echo "Matrix scanned: ${{ needs.setup-matrix.outputs.matrix }}"
